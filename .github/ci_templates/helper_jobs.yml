{!{ define "git_info_job" }!}
# <template: git_info_job>
{!{/*
Outputs:
  ci_commit_tag - used as CI_COMMIT_TAG variable to publish release images.
  ci_commit_branch - used as CI_COMMIT_BRANCH to publish images for main branch and dev images.
  ci_commit_ref_name - used as image tag to run e2e and deploy-web, and for release-channel-version image.
  github_sha - used as a key for caching images_tags_*.json file.

See:
- https://docs.github.com/en/actions/learn-github-actions/environment-variables
- https://github.com/actions/toolkit/blob/main/packages/github/src/context.ts

*/}!}
git_info:
  name: Get git info
  runs-on: ubuntu-latest
  outputs:
    ci_commit_tag: ${{ steps.git_info.outputs.ci_commit_tag }}
    ci_commit_branch: ${{ steps.git_info.outputs.ci_commit_branch }}
    ci_commit_ref_name: ${{ steps.git_info.outputs.ci_commit_ref_name }}
    ci_commit_ref_slug: ${{ steps.git_info.outputs.ci_commit_ref_slug }}
    ref_full: ${{ steps.git_info.outputs.ref_full }}
    github_sha: ${{ steps.git_info.outputs.github_sha }}
  # Skip the CI for automation PRs, e.g. changelog
  if: ${{ github.event.pull_request.user.login != 'deckhouse-BOaTswain' }}
  steps:
    - id: git_info
      name: Get tag name and SHA
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          const { GITHUB_REF_TYPE, GITHUB_REF_NAME, GITHUB_REF } = process.env

          let refSlug = ''
          let refName = ''
          let refFull = ''
          let githubBranch = ''
          let githubTag = ''
          let githubSHA = ''
          if (context.eventName === "workflow_dispatch" && context.payload.inputs && context.payload.inputs.pull_request_ref) {
            // Trigger: workflow_dispatch with pull_request_ref.
            // Extract pull request number from 'refs/pull/<NUM>/merge'
            const prNum   = context.payload.inputs.pull_request_ref.replace('refs/pull/', '').replace('/merge', '').replace('/head', '')

            refSlug       = `pr${prNum}`
            refName       = context.payload.inputs.ci_commit_ref_name
            refFull       = context.payload.inputs.pull_request_ref
            githubBranch  = refName
            githubSHA     = context.payload.inputs.pull_request_sha
            core.info(`workflow_dispatch event: set git info from inputs. inputs: ${JSON.stringify(context.payload.inputs)}`)
          } else if (context.eventName === "pull_request" || context.eventName === "pull_request_target" ) {
            // For PRs from forks, tag images with `prXXX` to avoid clashes between branches.
            const targetRepo = context.payload.repository.full_name;
            const prRepo = context.payload.pull_request.head.repo.full_name
            const prRef = context.payload.pull_request.head.ref

            refSlug = `pr${context.issue.number}`;
            refName = (prRepo === targetRepo) ? prRef : refSlug;
            refFull = `refs/pull/${context.issue.number}/head`
            githubBranch = refName
            githubSHA = context.payload.pull_request.head.sha
            core.info(`pull request event: set git info from pull_request.head. pr:${prRepo}:${prRef} target:${targetRepo}:${context.ref}`)
          } else {
            // Other triggers: workflow_dispatch without pull_request_ref, schedule, push...
            // refName is 'main' or tag name, so slugification is not necessary.
            refSlug       = GITHUB_REF_NAME
            refName       = GITHUB_REF_NAME
            refFull       = GITHUB_REF
            githubTag     = GITHUB_REF_TYPE == "tag"    ? refName : ""
            githubBranch  = GITHUB_REF_TYPE == "branch" ? refName : ""
            githubSHA     = context.sha
            core.info(`${context.eventName} event: set git info from context: ${JSON.stringify({GITHUB_REF_NAME, GITHUB_REF_TYPE, sha: context.sha })}`)
          }

          core.setCommandEcho(true)
          core.setOutput('ci_commit_ref_slug', refSlug)
          core.setOutput('ci_commit_ref_name', refName)
          core.setOutput(`ci_commit_tag`, githubTag)
          core.setOutput(`ci_commit_branch`, githubBranch)
          core.setOutput(`ref_full`, refFull)
          core.setOutput('github_sha', githubSHA)
          core.setCommandEcho(false)

# </template: git_info_job>
{!{- end -}!}


# Check pull request state on push or pull_request_target events:
# - find PR info on push event
# - detect edition from PR labels
# - calculate ref to use in further checkout jobs
# - detect if PR is 'external': checkout the head commit and fail if changes are not safe
{!{ define "pull_request_info_job" }!}
# <template: pull_request_info>
pull_request_info:
  name: Get pull request reference
  runs-on: ubuntu-latest
  outputs:
    ref: ${{ steps.check_pr.outputs.ref }}
    ref_slug: ${{ steps.check_pr.outputs.ref_slug }}
    edition: ${{ steps.check_pr.outputs.edition }}
    pr_title: ${{ steps.check_pr.outputs.pr_title }}
    pr_description: ${{ steps.check_pr.outputs.pr_description }}
    diff_url: ${{ steps.check_pr.outputs.diff_url }}
    labels: ${{ steps.check_pr.outputs.labels }}

  # Skip pull_request and pull_request_target triggers for PRs authored by deckhouse-BOaTswain, e.g. changelog PRs.
  if: ${{ ! (startsWith(github.event_name, 'pull_request') && github.event.pull_request.user.login == 'deckhouse-BOaTswain') }}
  steps:
    - name: Check push trigger
      id: check_push
      if: ${{ github.event_name == 'push' }}
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          // Support for 'push' trigger: find PR by commit SHA and pass response to check_pr step.
          const { GITHUB_REF_NAME } = process.env
          core.startGroup(`Fetching PR info for commit ${context.sha} in ${context.repo.name}:${GITHUB_REF_NAME} ...`)
          try {
            const response = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: context.sha
            });
            if (response.status !== 200 || !response.data || response.data.length === 0) {
              return core.setFailed(`Bad response on listing PRs for commit ${context.sha}: ${JSON.stringify(response)}`);
            }
            // Get first associated pr.
            const pr = response.data[0];
            // Reduce size to fit output limits.
            pr = {
              url:      pr.url,
              diff_url: pr.diff_url,
              number:   pr.number,
              labels:   pr.labels,
              head:     pr.head,
              title:    pr.title,
              body:     pr.body,
            }
            core.notice(`Found PR#{pr.number} for ${head_label}`);
            core.setOutput('pr_response', JSON.stringify(pr));
          } catch (error) {
            return core.setFailed(`Error listing pull requests for ${head_label}: ${error}`)
          } finally {
            core.endGroup()
          }

    - name: Check pull request
      id: check_pr
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      env:
        PR_FOR_PUSH: ${{ steps.check_push.outputs.pr_response}}
      with:
        script: |
          let pr = null
          let isPullRequest = false

          // Restore pull request info from env.
          if (context.eventName === 'push') {
            pr = JSON.parse(process.env.PR_FOR_PUSH);
            isPush = true
          }
          if (context.eventName.startsWith('pull_request')) {
            pr = context.payload.pull_request
            isPullRequestEvent = true
          }

          if (!pr) {
            return core.setFailed(`No pull request context: event_name=${context.eventName} action=${context.action} ref=${context.ref}`);
          }

          const head_owner = pr.head.repo.owner.login
          const head_repo = pr.head.repo.name
          const head_commit_sha = pr.head.sha
          const head_label = pr.head.label
          const head_ref = pr.head.ref
          const pr_repo = pr.head.repo.full_name
          const target_repo = context.payload.repository.full_name
          const owner = context.repo.owner
          const repo = context.repo.repo
          core.startGroup(`Pull request context`)
          core.info(`PR owner                ${head_owner}`)
          core.info(`PR repo                 ${head_repo}`)
          core.info(`PR repo full_name       ${pr_repo}`)
          core.info(`PR commit SHA           ${head_commit_sha}`)
          core.info(`PR head label           ${head_label}`)
          core.info(`PR head ref             ${head_ref}`)
          core.info(`Target owner            ${owner}`)
          core.info(`Target repo             ${repo}`)
          core.info(`Target repo full_name   ${target_repo}`)
          core.endGroup()

          let prLabels = null
          if (isPullRequestEvent) {
            // Fetch fresh pull request state using sha.
            // Why? Workflow rerun of 'opened' pull request contains outdated labels.
            core.startGroup(`Fetching labels for PR#${pr.number} from Github API`)
            try {
              const response = await github.rest.pulls.get({owner, repo, pull_number: pr.number})
              if (response.status != 200) {
                return core.setFailed(`Fetch PR#${pr.number} problem: ${JSON.stringify(response)}`);
              }
              if (!response.data) {
                return core.setFailed(`Empty response data for PR#${pr.number}: ${JSON.stringify(response)}. event_name=${context.eventName} action=${context.action} ref=${context.ref}`);
              }
              // Only labels are needed.
              prLabels = response.data.labels
              core.info(`Labels from context: ${JSON.stringify(pr.labels)}`);
              core.info(`Current labels: ${JSON.stringify(prLabels)}`);
            } catch (error) {
              return core.setFailed(`Fetch PR#${pr.number} error: ${error}`)
            } finally {
              core.endGroup()
            }
          } else {
            prLabels = pr.labels
            core.info(`Current labels: ${JSON.stringify(prLabels)}`);
          }

          const isInternal = pr_repo === target_repo;
          const isDependabot = (context.actor === 'dependabot[bot]');
          const isChangelog = head_ref.startsWith('changelog/v');
          const okToTest = prLabels.some((l) => l.name === 'status/ok-to-test');

          core.info(`PR internal?          ${isInternal}`)
          core.info(`PR from dependabot?   ${isDependabot}`)
          core.info(`PR changelog?         ${isChangelog}`)
          core.info(`PR has 'ok-to-test'?  ${okToTest}`)

          let shouldCheckFiles = 'false'
          if (isInternal && !isDependabot) {
            // Ignore changelog pull requests.
            if (isChangelog) {
              return core.setFailed(`PR#${pr.number} for changelog is ignored.`);
            }
          } else {
            // External and dependabot pull requests should be labeled with 'status/ok-to-test'.
            if (!okToTest) {
              return core.setFailed(`PR#${pr.number} without label 'status/ok-to-test' is ignored.`);
            }
            shouldCheckFiles = 'true'
          }
          core.info(`PR may be dangerous?  ${shouldCheckFiles}`)

          // Set edition from current labels.
          var defaultEdition = process.env.WERF_ENV ? process.env.WERF_ENV : 'FE';
          const isEE = prLabels.some((l) => l.name === 'edition/ee');
          core.info(`PR has 'edition/ee'?  ${isEE}`);
          const isCE = prLabels.some((l) => l.name === 'edition/ce');
          core.info(`PR has 'edition/ce'?  ${isCE}`);
          const edition = isCE ? 'CE' : (isEE ? 'EE' : defaultEdition);

          const ref = `refs/pull/${ pr.number }/head`;

          core.notice(`Enable '${edition}' edition for '${context.eventName}' trigger.`);
          core.notice(`Use ref: '${ref}'`)

          // pr.diff_url works only for public repositories.
          let diff_url = pr.diff_url;
          if (!!context.payload.repository.private) {
            core.notice(`Detect private repo. Use Github API to get PR diff.`);
            diff_url = pr.url;
          }

          core.setCommandEcho(true)
          core.setOutput('should_check', shouldCheckFiles);
          core.setOutput('ref', ref);
          core.setOutput('ref_slug', `pr${pr.number}`);
          core.setOutput('edition', edition);
          core.setOutput('pr_title', pr.title);
          core.setOutput('pr_description', pr.body);
          core.setOutput('diff_url', diff_url);
          core.setOutput('labels', JSON.stringify(pr.labels));
          core.setCommandEcho(false);

    # Checkhout the head commit of the PR branch.
    - name: Checkout PR head commit
      if: steps.check_pr.outputs.should_check == 'true'
      uses: {!{ index (ds "actions") "actions/checkout" }!}
      with:
        ref: ${{ steps.check_pr.outputs.ref }}

    # Detect dangerous changes in external PR.
    - name: Check for dangerous changes
      uses: {!{ index (ds "actions") "dorny/paths-filter" }!}
      if: steps.check_pr.outputs.should_check == 'true'
      id: changes
      with:
        token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
        filters: |
          dangerous:
            - './.github/**'
            - './tools/**'
            - './testing/**'
            - './docs/**/js/**'
            - './docs/**/css/**'
            - './docs/**/images/**'
            - './docs/**/assets/**'

    # Stop workflow if external PR contains dangerous changes.
    - name: Fail workflow on dangerous changes
      if: steps.changes.outputs.dangerous == 'true'
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          core.setFailed('External PR contains dangerous changes.')

# </template: pull_request_info>
{!{- end -}!}
