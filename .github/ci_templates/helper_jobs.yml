{!{ define "git_info_job" }!}
# <template: git_info_job>
{!{/*
Outputs:
  ci_commit_tag - used as CI_COMMIT_TAG variable to publish release images.
  ci_commit_branch - used as CI_COMMIT_BRANCH to publish images for main branch and dev images.
  ci_commit_ref_name - used as image tag to run e2e and deploy-web, and for release-channel-version image.
  github_sha - used as a key for caching images_tags_*.json file.

See:
- https://docs.github.com/en/actions/learn-github-actions/environment-variables
- https://github.com/actions/toolkit/blob/main/packages/github/src/context.ts

*/}!}
git_info:
  name: Get git info
  runs-on: ubuntu-latest
  outputs:
    ci_commit_tag: ${{ steps.git_info.outputs.ci_commit_tag }}
    ci_commit_branch: ${{ steps.git_info.outputs.ci_commit_branch }}
    ci_commit_ref_name: ${{ steps.git_info.outputs.ci_commit_ref_name }}
    ci_commit_ref_slug: ${{ steps.git_info.outputs.ci_commit_ref_slug }}
    ref_full: ${{ steps.git_info.outputs.ref_full }}
    github_sha: ${{ steps.git_info.outputs.github_sha }}
  # Skip the CI for automation PRs, e.g. changelog
  if: ${{ github.event.pull_request.user.login != 'deckhouse-BOaTswain' }}
  steps:
    - id: git_info
      name: Get tag name and SHA
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          const { GITHUB_REF_TYPE, GITHUB_REF_NAME, GITHUB_REF } = process.env

          let refSlug = ''
          let refName = ''
          let refFull = ''
          let githubBranch = ''
          let githubTag = ''
          let githubSHA = ''
          if (context.eventName === "workflow_dispatch" && context.payload.inputs && context.payload.inputs.pull_request_ref) {
            // Trigger: workflow_dispatch with pull_request_ref.
            // Extract pull request number from 'refs/pull/<NUM>/merge'
            const prNum   = context.payload.inputs.pull_request_ref.replace('refs/pull/', '').replace('/merge', '').replace('/head', '')

            refSlug       = `pr${prNum}`
            refName       = context.payload.inputs.ci_commit_ref_name
            refFull       = context.payload.inputs.pull_request_ref
            githubBranch  = refName
            githubSHA     = context.payload.inputs.pull_request_sha
            core.info(`workflow_dispatch event: set git info from inputs. inputs: ${JSON.stringify(context.payload.inputs)}`)
          } else if (context.eventName === "pull_request" || context.eventName === "pull_request_target" ) {
            // For PRs from forks, tag images with `prXXX` to avoid clashes between branches.
            const targetRepo = context.payload.repository.full_name;
            const prRepo = context.payload.pull_request.head.repo.full_name
            const prRef = context.payload.pull_request.head.ref

            refSlug = `pr${context.issue.number}`;
            refName = (prRepo === targetRepo) ? prRef : refSlug;
            refFull = `refs/pull/${context.issue.number}/head`
            githubBranch = refName
            githubSHA = context.payload.pull_request.head.sha
            core.info(`pull request event: set git info from pull_request.head. pr:${prRepo}:${prRef} target:${targetRepo}:${context.ref}`)
          } else {
            // Other triggers: workflow_dispatch without pull_request_ref, schedule, push...
            // refName is 'main' or tag name, so slugification is not necessary.
            refSlug       = GITHUB_REF_NAME
            refName       = GITHUB_REF_NAME
            refFull       = GITHUB_REF
            githubTag     = GITHUB_REF_TYPE == "tag"    ? refName : ""
            githubBranch  = GITHUB_REF_TYPE == "branch" ? refName : ""
            githubSHA     = context.sha
            core.info(`${context.eventName} event: set git info from context: ${JSON.stringify({GITHUB_REF_NAME, GITHUB_REF_TYPE, sha: context.sha })}`)
          }

          core.setCommandEcho(true)
          core.setOutput('ci_commit_ref_slug', refSlug)
          core.setOutput('ci_commit_ref_name', refName)
          core.setOutput(`ci_commit_tag`, githubTag)
          core.setOutput(`ci_commit_branch`, githubBranch)
          core.setOutput(`ref_full`, refFull)
          core.setOutput('github_sha', githubSHA)
          core.setCommandEcho(false)

# </template: git_info_job>
{!{- end -}!}


# Only useful with pull_request_target.
#
# Checkout the head commit, checks if changes are safe and returns the ref.
# Job fails if changes seem dangerous.
{!{ define "pull_request_info_job" }!}
# <template: pull_request_info>
pull_request_info:
  name: Get pull request reference
  runs-on: ubuntu-latest
  outputs:
    ref: ${{ steps.ref.outputs.ref }}
    edition: ${{ steps.check_pr.outputs.edition || steps.check_push.outputs.edition }}
  # Skip pull_request and pull_request_target triggers for PRs authored by deckhouse-BOaTswain, e.g. changelog PRs.
  if: ${{ ! (startsWith(github.event_name, 'pull_request') && github.event.pull_request.user.login == 'deckhouse-BOaTswain') }}
  steps:
    - name: Check push trigger
      id: check_push
      if: ${{ github.event_name == 'push' }}
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          // Support 'push' trigger: use FE edition by default.
          const edition = process.env.WERF_ENV ? process.env.WERF_ENV : 'FE';
          core.notice(`Enable default '${edition}' edition for 'push' trigger.`);
          return core.setOutput('edition', edition);

    - name: Check if allow to run tests
      id: check_pr
      if: ${{ startsWith(github.event_name, 'pull_request') }}
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          if (!context.payload.pull_request) {
            return core.setFailed(`Unknown event, no pull request context. event_name=${context.eventName} action=${context.action} ref=${context.ref}`);
          }

          const pr = context.payload.pull_request

          const head_owner = pr.head.repo.owner.login
          const head_repo = pr.head.repo.name
          const head_commit_sha = pr.head.sha
          const head_label = pr.head.label
          const head_ref = pr.head.ref
          const pr_repo = pr.head.repo.full_name
          const target_repo = context.payload.repository.full_name
          const owner = context.repo.owner
          const repo = context.repo.repo
          core.startGroup(`Pull request context`)
          core.info(`PR owner                ${head_owner}`)
          core.info(`PR repo                 ${head_repo}`)
          core.info(`PR repo full_name       ${pr_repo}`)
          core.info(`PR commit SHA           ${head_commit_sha}`)
          core.info(`PR head label           ${head_label}`)
          core.info(`PR head ref             ${head_ref}`)
          core.info(`Target owner            ${owner}`)
          core.info(`Target repo             ${repo}`)
          core.info(`Target repo full_name   ${target_repo}`)
          core.endGroup()

          // Fetch fresh pull request state using sha.
          // Why? Workflow rerun of 'opened' pull request contains outdated labels.
          core.startGroup(`Fetching labels for PR#${pr.number} from Github API`)
          let prLabels = []
          try {
            const response = await github.rest.pulls.get({owner, repo, pull_number: pr.number})
            if (response.status != 200) {
              return core.setFailed(`Fetch PR#${pr.number} problem: ${JSON.stringify(response)}`);
            }
            if (!response.data) {
              return core.setFailed(`Empty response data for PR#${pr.number}: ${JSON.stringify(response)}. event_name=${context.eventName} action=${context.action} ref=${context.ref}`);
            }
            // Only labels are needed.
            prLabels = response.data.labels
            core.info(`Labels from context: ${JSON.stringify(pr.labels)}`);
            core.info(`Current labels: ${JSON.stringify(prLabels)}`);
          } catch (error) {
            return core.setFailed(`Fetch PR#${pr.number} error: ${error}`)
          } finally {
            core.endGroup()
          }


          const isInternal = pr_repo === target_repo;
          const isDependabot = (context.actor === 'dependabot[bot]');
          const isChangelog = head_ref.startsWith('changelog/v');
          const okToTest = prLabels.some((l) => l.name === 'status/ok-to-test');

          core.info(`PR internal?          ${isInternal}`)
          core.info(`PR from dependabot?   ${isDependabot}`)
          core.info(`PR changelog?         ${isChangelog}`)
          core.info(`PR has 'ok-to-test'?  ${okToTest}`)

          let shouldCheckFiles = 'false'
          if (isInternal && !isDependabot) {
            // Ignore changelog pull requests.
            if (isChangelog) {
              return core.setFailed(`PR#${pr.number} for changelog is ignored.`);
            }
          } else {
            // External and dependabot pull requests should be labeled with 'status/ok-to-test'.
            if (!okToTest) {
              return core.setFailed(`PR#${pr.number} without label 'status/ok-to-test' is ignored.`);
            }
            shouldCheckFiles = 'true'
          }
          core.info(`PR may be dangerous?  ${shouldCheckFiles}`)

          // Set edition from current labels.
          var defaultEdition = process.env.WERF_ENV ? process.env.WERF_ENV : 'FE';
          const isEE = prLabels.some((l) => l.name === 'edition/ee');
          core.info(`PR has 'edition/ee'?  ${isEE}`);
          const isCE = prLabels.some((l) => l.name === 'edition/ce');
          core.info(`PR has 'edition/ce'?  ${isCE}`);
          const edition = isCE ? 'CE' : (isEE ? 'EE' : defaultEdition);
          core.notice(`Enable '${edition}' edition.`);

          core.setCommandEcho(true)
          core.setOutput('should_check', shouldCheckFiles);
          core.setOutput('edition', edition);
          core.setCommandEcho(false)

    # Checkhout the head commit of the PR branch.
    - name: Checkout PR head commit
      if: ${{ startsWith(github.event_name, 'pull_request') }}
      uses: {!{ index (ds "actions") "actions/checkout" }!}
      with:
        ref: "refs/pull/${{ github.event.number }}/head"

    # Detect dangerous changes in external PR.
    - name: Check for dangerous changes
      uses: {!{ index (ds "actions") "dorny/paths-filter" }!}
      if: steps.check_pr.outputs.should_check == 'true'
      id: changes
      with:
        token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
        filters: |
          dangerous:
            - './.github/**'
            - './tools/**'
            - './testing/**'
            - './docs/**/js/**'
            - './docs/**/css/**'
            - './docs/**/images/**'
            - './docs/**/assets/**'

    # Stop workflow if external PR contains dangerous changes.
    - name: Fail workflow on dangerous changes
      if: steps.changes.outputs.dangerous == 'true'
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          core.setFailed('External PR contains dangerous changes.')

    # Set output.
    - name: Return PR head commit ref
      id: ref
      uses: {!{ index (ds "actions") "actions/github-script" }!}
      with:
        script: |
          // context.ref is set for 'push' and 'workflow_dispatch' triggers.
          let ref = context.ref;
          if (context.eventName.startsWith('pull_request')) {
            ref = `refs/pull/${ context.issue.number }/head`
          }
          if (context.eventName === 'workflow_dispatch' && context.payload.inputs && context.payload.inputs.pull_request_ref) {
            ref = context.payload.inputs.pull_request_ref;
          }
          if (context.eventName === 'push') {
            // Find PR number for branch or fail.
            const { GITHUB_REF_NAME } = process.env
            // Head label has form organization:branch_name.
            const head_label = `${context.repo.name}:${GITHUB_REF_NAME}`
            core.startGroup(`Fetching PR info for ${head_label} from Github API`)
            let prNumber = ''
            try {
              const response = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                head: head_label
              });
              if (response.status != 200) {
                return core.setFailed(`Fetch pull requests for ${head_label} problem: ${JSON.stringify(response)}`);
              }
              if (!response.data) {
                return core.setFailed(`Empty response data for ${head_label}: ${JSON.stringify(response)}. event_name=${context.eventName} action=${context.action} ref=${context.ref}`);
              }
              // Get first pull request.
              prNumber = response.data[0].number
              core.info(`Got PR#{prNumber} for ${head_label}`);
              ref = `refs/pull/${ prNumber }/head`;
            } catch (error) {
              return core.setFailed(`Fetch pull requests for ${head_label} error: ${error}`)
            } finally {
              core.endGroup()
            }
          }
          core.notice(`Use ref: '${ref}'`)
          core.setCommandEcho(true)
          core.setOutput('ref', ref)
          core.setCommandEcho(false)
# </template: pull_request_info>
{!{- end -}!}
