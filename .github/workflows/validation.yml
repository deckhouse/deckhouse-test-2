#
# THIS FILE IS GENERATED, PLEASE DO NOT EDIT.
#

# Run validation script on every push to dev branches.
#
# Validation scripts require  PR title, PR description and diff.
# Title and description are available when PR is already created.
# Diff content is fetched using 'diff_url' field in payload when PR is available.
# If PR is not created, 'compare' field is used to get diff between base branch and dev branch.
#
# See also scripts/validation_run.sh.
#

name: Validations
on:
  pull_request_target:
     types:
      - opened
      - synchronize

# Cancel in-progress jobs for the same PR (pull_request_target event) or for the same branch (push event).
concurrency:
  group: ${{ github.workflow }}-${{ github.event.number || github.ref }}
  cancel-in-progress: true

jobs:
  close_dependabot_prs_for_forks:
    name: Autoclose Dependabot PRs for forks
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' && github.repository != 'deckhouse/deckhouse' }}
    env:
      ENABLE_DEPENDABOT_IN_FORKS: ${{ secrets.ENABLE_DEPENDABOT_IN_FORKS }}
    steps:
      - name: Close PR
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          script: |
            // Keep PR if explicitly enabled.
            const {ENABLE_DEPENDABOT_IN_FORKS} = process.env;
            const prNum = context.payload.pull_request.number;
            const repo = context.payload.repository.full_name;
            if (ENABLE_DEPENDABOT_IN_FORKS === 'true') {
              core.info(`Secret ENABLE_DEPENDABOT_IN_FORKS is 'true', proceed with validation for PR#${prNUM} in repo ${repo}.`);
              return
            }
            core.info(`Secret ENABLE_DEPENDABOT_IN_FORKS is not 'true', close PR#${prNum} in repo ${repo}.`);
            return await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNum,
              state: 'closed'
            });


  # <template: pull_request_info>
  pull_request_info:
    name: Get pull request reference
    runs-on: ubuntu-latest
    outputs:
      ref: ${{ steps.check_pr.outputs.ref }}
      ref_slug: ${{ steps.check_pr.outputs.ref_slug }}
      edition: ${{ steps.check_pr.outputs.edition }}
    # Skip pull_request and pull_request_target triggers for PRs authored by deckhouse-BOaTswain, e.g. changelog PRs.
    if: ${{ ! (startsWith(github.event_name, 'pull_request') && github.event.pull_request.user.login == 'deckhouse-BOaTswain') }}
    steps:
      - name: Check push trigger
        id: check_push
        if: ${{ github.event_name == 'push' }}
        uses: actions/github-script@v5.0.0
        with:
          script: |
            // Support for 'push' trigger: find PR by commit SHA and pass response to check_pr step.
            const { GITHUB_REF_NAME } = process.env
            core.startGroup(`Fetching PR info for commit ${context.sha} in ${context.repo.name}:${GITHUB_REF_NAME} ...`)
            try {
              const response = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: context.sha
              });
              if (response.status !== 200 || !response.data || response.data.length === 0) {
                return core.setFailed(`Bad response on listing PRs for commit ${context.sha}: ${JSON.stringify(response)}`);
              }
              // Get first associated pr.
              const pr = response.data[0];
              // Reduce size to fit output limits.
              pr = {
                number: pr.number,
                labels: pr.labels,
                head: pr.head
              }
              core.notice(`Found PR#{pr.number} for ${head_label}`);
              core.setOutput('pr_response', JSON.stringify(pr));
            } catch (error) {
              return core.setFailed(`Error listing pull requests for ${head_label}: ${error}`)
            } finally {
              core.endGroup()
            }

  #          //let ref = '';
  #          //let prLabels = null;
  #            //ref = `refs/pull/${pr.number}/head`;
  #          const edition = process.env.WERF_ENV ? process.env.WERF_ENV : 'FE';
  #          core.notice(`Enable default '${edition}' edition for 'push' trigger.`);
  #
  #          // Set edition from current labels.
  #          var defaultEdition = process.env.WERF_ENV ? process.env.WERF_ENV : 'FE';
  #          const isEE = prLabels.some((l) => l.name === 'edition/ee');
  #          core.info(`PR has 'edition/ee'?  ${isEE}`);
  #          const isCE = prLabels.some((l) => l.name === 'edition/ce');
  #          core.info(`PR has 'edition/ce'?  ${isCE}`);
  #          const edition = isCE ? 'CE' : (isEE ? 'EE' : defaultEdition);
  #
  #          core.notice(`Enable '${edition}' edition for '${context.eventName}' trigger.`);
  #          core.notice(`Use ref: '${ref}'`)
  #
  #          core.setCommandEcho(true)
  #          core.setOutput('ref', ref)
  #          core.setOutput('edition', edition);
  #          core.setCommandEcho(false)

      - name: Check pull request
        id: check_pr
        #if: ${{ startsWith(github.event_name, 'pull_request') }}
        uses: actions/github-script@v5.0.0
        env:
          PR_FOR_PUSH: ${{ steps.check_push.outputs.pr_response}}
        with:
          script: |
            let pr = null
            let isPullRequest = false

            // Restore pull request info from env.
            if (context.eventName === 'push') {
              pr = JSON.parse(process.env.PR_FOR_PUSH);
              isPush = true
            }
            if (context.eventName.startsWith('pull_request')) {
              pr = context.payload.pull_request
              isPullRequestEvent = true
            }

            if (!pr) {
              return core.setFailed(`No pull request context: event_name=${context.eventName} action=${context.action} ref=${context.ref}`);
            }

            const head_owner = pr.head.repo.owner.login
            const head_repo = pr.head.repo.name
            const head_commit_sha = pr.head.sha
            const head_label = pr.head.label
            const head_ref = pr.head.ref
            const pr_repo = pr.head.repo.full_name
            const target_repo = context.payload.repository.full_name
            const owner = context.repo.owner
            const repo = context.repo.repo
            core.startGroup(`Pull request context`)
            core.info(`PR owner                ${head_owner}`)
            core.info(`PR repo                 ${head_repo}`)
            core.info(`PR repo full_name       ${pr_repo}`)
            core.info(`PR commit SHA           ${head_commit_sha}`)
            core.info(`PR head label           ${head_label}`)
            core.info(`PR head ref             ${head_ref}`)
            core.info(`Target owner            ${owner}`)
            core.info(`Target repo             ${repo}`)
            core.info(`Target repo full_name   ${target_repo}`)
            core.endGroup()

            let prLabels = null
            if (isPullRequestEvent) {
              // Fetch fresh pull request state using sha.
              // Why? Workflow rerun of 'opened' pull request contains outdated labels.
              core.startGroup(`Fetching labels for PR#${pr.number} from Github API`)
              try {
                const response = await github.rest.pulls.get({owner, repo, pull_number: pr.number})
                if (response.status != 200) {
                  return core.setFailed(`Fetch PR#${pr.number} problem: ${JSON.stringify(response)}`);
                }
                if (!response.data) {
                  return core.setFailed(`Empty response data for PR#${pr.number}: ${JSON.stringify(response)}. event_name=${context.eventName} action=${context.action} ref=${context.ref}`);
                }
                // Only labels are needed.
                prLabels = response.data.labels
                core.info(`Labels from context: ${JSON.stringify(pr.labels)}`);
                core.info(`Current labels: ${JSON.stringify(prLabels)}`);
              } catch (error) {
                return core.setFailed(`Fetch PR#${pr.number} error: ${error}`)
              } finally {
                core.endGroup()
              }
            } else {
              prLabels = pr.labels
              core.info(`Current labels: ${JSON.stringify(prLabels)}`);
            }

            const isInternal = pr_repo === target_repo;
            const isDependabot = (context.actor === 'dependabot[bot]');
            const isChangelog = head_ref.startsWith('changelog/v');
            const okToTest = prLabels.some((l) => l.name === 'status/ok-to-test');

            core.info(`PR internal?          ${isInternal}`)
            core.info(`PR from dependabot?   ${isDependabot}`)
            core.info(`PR changelog?         ${isChangelog}`)
            core.info(`PR has 'ok-to-test'?  ${okToTest}`)

            let shouldCheckFiles = 'false'
            if (isInternal && !isDependabot) {
              // Ignore changelog pull requests.
              if (isChangelog) {
                return core.setFailed(`PR#${pr.number} for changelog is ignored.`);
              }
            } else {
              // External and dependabot pull requests should be labeled with 'status/ok-to-test'.
              if (!okToTest) {
                return core.setFailed(`PR#${pr.number} without label 'status/ok-to-test' is ignored.`);
              }
              shouldCheckFiles = 'true'
            }
            core.info(`PR may be dangerous?  ${shouldCheckFiles}`)

            // Set edition from current labels.
            var defaultEdition = process.env.WERF_ENV ? process.env.WERF_ENV : 'FE';
            const isEE = prLabels.some((l) => l.name === 'edition/ee');
            core.info(`PR has 'edition/ee'?  ${isEE}`);
            const isCE = prLabels.some((l) => l.name === 'edition/ce');
            core.info(`PR has 'edition/ce'?  ${isCE}`);
            const edition = isCE ? 'CE' : (isEE ? 'EE' : defaultEdition);

            const ref = `refs/pull/${ pr.number }/head`;

            core.notice(`Enable '${edition}' edition for '${context.eventName}' trigger.`);
            core.notice(`Use ref: '${ref}'`)

            core.setCommandEcho(true)
            core.setOutput('should_check', shouldCheckFiles);
            core.setOutput('ref', ref);
            core.setOutput('refSlug', `pr${pr.number}`);
            core.setOutput('edition', edition);
            core.setCommandEcho(false);

      # Checkhout the head commit of the PR branch.
      - name: Checkout PR head commit
        if: steps.check_pr.outputs.should_check == 'true'
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ steps.check_pr.outputs.ref }}

      # Detect dangerous changes in external PR.
      - name: Check for dangerous changes
        uses: dorny/paths-filter@v2
        if: steps.check_pr.outputs.should_check == 'true'
        id: changes
        with:
          token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          filters: |
            dangerous:
              - './.github/**'
              - './tools/**'
              - './testing/**'
              - './docs/**/js/**'
              - './docs/**/css/**'
              - './docs/**/images/**'
              - './docs/**/assets/**'

      # Stop workflow if external PR contains dangerous changes.
      - name: Fail workflow on dangerous changes
        if: steps.changes.outputs.dangerous == 'true'
        uses: actions/github-script@v5.0.0
        with:
          script: |
            core.setFailed('External PR contains dangerous changes.')

  # </template: pull_request_info>

  # Get pull request info for validation scripts.
  # Push event has no pull request information, so retrieve it with Rest API.
  discover:
    name: Prepare input for validation scripts
    needs:
      - pull_request_info
    runs-on: ubuntu-latest
    outputs:
      run_no_cyrillic: ${{ steps.on_push.outputs.run_no_cyrillic }}
      label_no_cyrillic: ${{ steps.on_push.outputs.label_no_cyrillic }}
      run_doc_changes: ${{ steps.on_push.outputs.run_doc_changes }}
      label_doc_changes: ${{ steps.on_push.outputs.label_doc_changes }}
      run_copyright: ${{ steps.on_push.outputs.run_copyright }}
      label_copyright: ${{ steps.on_push.outputs.label_copyright }}
      run_markdown: ${{ steps.on_push.outputs.run_markdown }}
      label_markdown: ${{ steps.on_push.outputs.label_markdown }}
      pr_title: ${{ steps.on_push.outputs.pr_title }}
      pr_description: ${{ steps.on_push.outputs.pr_description }}
      diff_url: ${{ steps.on_push.outputs.diff_url }}

    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ needs.pull_request_info.outputs.ref }}
      # </template: checkout_step>
      - id: on_push
        name: Check labels on push
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const ci = require('./.github/scripts/js/ci');
            return await ci.checkValidationLabels({ github, context, core });

      - name: Download diff for pull request
        env:
          IS_PRIVATE_REPO: ${{ steps.on_push.outputs.is_private_repo }}
          DIFF_URL: ${{ steps.on_push.outputs.diff_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ./.github/scripts/validation_run.sh --download-only ./pr.diff

      - name: Upload diff as artifact
        uses: actions/upload-artifact@v2
        with:
          name: pr_diff
          path: pr.diff


  no_cyrillic_validation:
    name: No Cyrillic Validation
    env:
      VALIDATE_TITLE: ${{ needs.discover.outputs.pr_title }}
      VALIDATE_DESCRIPTION: ${{ needs.discover.outputs.pr_description }}

    needs:
      - discover
      - pull_request_info
    if: needs.discover.outputs.run_no_cyrillic == 'true'
    runs-on: ubuntu-latest
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ needs.pull_request_info.outputs.ref }}
      # </template: checkout_step>

      - name: Restore diff artifact
        uses: actions/download-artifact@v2
        with:
          name: pr_diff

      - name: Run check
        env:
          DIFF_PATH: ./pr.diff
          SKIP_LABEL_NAME: ${{ needs.discover.outputs.label_no_cyrillic }}
        run: |
          ./.github/scripts/validation_run.sh ./testing/validate_no_cyrillic.sh

  doc_validation:
    name: Documentation Validation

    needs:
      - discover
      - pull_request_info
    if: needs.discover.outputs.run_doc_changes == 'true'
    runs-on: ubuntu-latest
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ needs.pull_request_info.outputs.ref }}
      # </template: checkout_step>

      - name: Restore diff artifact
        uses: actions/download-artifact@v2
        with:
          name: pr_diff

      - name: Run check
        env:
          DIFF_PATH: ./pr.diff
          SKIP_LABEL_NAME: ${{ needs.discover.outputs.label_doc_changes }}
        run: |
          ./.github/scripts/validation_run.sh ./testing/validate_doc_changes.sh

  copyright_validation:
    name: Copyright Validation

    needs:
      - discover
      - pull_request_info
    if: needs.discover.outputs.run_copyright == 'true'
    runs-on: ubuntu-latest
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ needs.pull_request_info.outputs.ref }}
      # </template: checkout_step>

      - name: Restore diff artifact
        uses: actions/download-artifact@v2
        with:
          name: pr_diff

      - name: Run check
        env:
          DIFF_PATH: ./pr.diff
          SKIP_LABEL_NAME: ${{ needs.discover.outputs.label_copyright }}
        run: |
          ./.github/scripts/validation_run.sh ./testing/validate_copyright.sh

  markdown_linter:
    name: Markdown Linter

    needs:
      - discover
      - pull_request_info
    if: needs.discover.outputs.run_markdown == 'true'
    runs-on: ubuntu-latest
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ needs.pull_request_info.outputs.ref }}
      # </template: checkout_step>

      - name: Restore diff artifact
        uses: actions/download-artifact@v2
        with:
          name: pr_diff

      - name: Run linter
        env:
          DIFF_PATH: ./pr.diff
          SKIP_LABEL_NAME: ${{ needs.discover.outputs.label_markdown }}
        run: |
          make lint-markdown

